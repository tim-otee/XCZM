#----------------------------------------------------------------------#
'''              Multiple OTF crack propagation in 3D-XCZM   
                     through Super-Critical loading
                 -----------------------------------------        
                              (OCT 2016)                

Contents:
		[1/4] Notes on use
		[2/4] Crack syntax
		[3/4] Model testing list
		[4/4] Model set-up: 3 Phases
		
#----------------------------------------------------------------------#	
[1/4] Notes on use
#----------------------------------------------------------------------#

The model must have a first crack to propagate. If only N_FISS populated 
it will fail with the contact due to nodes (either incease time or force).

When changeing geometries/meshes several parts of the model need to be 
changed:
		1 - Naming of DEFI_GROUP in PHASE 1 and 2
		2 - Contact for for CTX needs each crack explicitly defined
		3 - h_min - Needs to be minimum element size of mesh
		4 - int_nb_cracks - needs to be number of cracks defined
		5 - L_Int_Crack - list of intial cracks

When cracks get close to interaction da_max needs to be reduced to avoid 
cracks contacting

#----------------------------------------------------------------------#
[2/4] Crack syntax:
#----------------------------------------------------------------------#

	1 Naming:	
	
	  - Intial cracks
	 	FISS[ C_0_QSTATIC(0)_nbcalc ][ C_0_DYNAMIC(1)_nbcalc ] * number of cracks
	  - Propagating cracks 
		FISP[ P_0_QSTATIC(0)_nbcalc ][ P_0_DYNAMIC(1)_nbcalc ] * number of cracks		
	  - New cracks 	
	 	FISS[ C_0_QSTATIC(0)_nbcalc+1 ][ C_0_DYNAMIC(1)_nbcalc+1 ] * number of cracks	
				
	2 Propagation criteria
	
	  TEST 1 - Does it arrest?
	  TEST 2 - Does it Propagate beyond cohezive zone (CZ)?
	  TEST 3 - Propagate the crack, ok?
		
	3 Sorting hats (bins):
	
	  P_FISS  = Passed TEST 1 and 2  - crack to be propagated
	  N_FISS  = Failed TEST 1        - crack not intiated 
	  A_FISS  = Failed TEST 2        - crack arrested  
	  PN_FISS = Failed TEST 2        - not propagated beyond CZ
		                                
#----------------------------------------------------------------------#
[3/4] Model testing list:
#----------------------------------------------------------------------#

	1 Correct inititations - above critical loading 
	  - Should Populate N_FISS
	2 Correct propagations- below critical loading 
	  - Should Populate P_FISS
	3 Correct crack extension to propagate - large n*h_min 
	  - Should Populate PN_FISS
	4 Arrested during propagation - Not implimented atm Defaults N_FISS
	  - Should Populate A_FISS

#----------------------------------------------------------------------#	
[4/4] Model set-up: 3 Phases
#----------------------------------------------------------------------#

Phase 1 Find a loading for model which is just above critcal stress
		[1] Uses a while loop and iterative if statement to reach limit
		[2] Linearly extrapolate from intial loading and adds 1% to
		    breach Critical Stress

Phase 2 propgates multiple cracks through a sampling algorithum
          which detects intitating and stop-starting cracks. 
                                            
		Structure: -

		[1] Preamble
			- Material properties, Time-stepping, List of test instances
			- Read and name mesh componants
				- Crack fronts need to be named (FONDINI_n)
			- Define model vectors et material (aster object)
		[2] Define intial list of cracks - (crack preamble)
			- define each crack (DEFI_FISS_XFEM)
			- detect intial crack fronts (PROPA_FISS)
		[3] Propagation for loop over INST list
			- Quasi-static <---------------------------|
				- Contact - all defined cracks         |
			- Dynamic                                  |
			- TEST CRITERION                           |
				- Calc_G intial crack                  |
					- (has it arrested?)			   | 
				- Detect crack fronts 	               | 
				- IF lc < da. 5*h_min                  |
					- IF Prop- + P_FISS -> PROPAGATE   |
					- IF NOT- + N_FISS                 |
			- tuple(P_FISS + N_FISS)                   |
			- (loop)-----------------------------------|
		
		*** Crack Naming Syntax ***
		.... 
		[4] Post-processing 
			- Ouput final mesh step 
			- Output resu depl, stress etc


Phase 3 Post processing 	



''' 
#----------------------------------------------------------------------#
DEBUT(PAR_LOT ='NON',
      #IMPR_MACRO='OUI',
      CODE=_F(NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),
      IGNORE_ALARM=('SUPERVIS_22','SUPERVIS_1','XFEM_94','MECANONLINE_2'),); 



# Material Properties
young = 32.E3
poiss = 0.2
Gc = 0.003
Sc = 2.8
rho = 2.45E-9
pena_lag = 2.*Sc*Sc/Gc

#Applied Loadings
pressures=pressured=2*2.6*0.191497266711#0.1 #8.
percential= 10          # 100 equates to 1% critical load

# Quasi-static time steps DO NOT CHANGE!!!
tdyn = 1.E-5
nbpas = 1

# Dynamic Calculation parameters
#nbcalc =3 #19                     # Must align to number of instfin
nbpady =4000                      # Number of steps explicit 
deltat = 2.e-8                  # CDM explicit step size
nbpas_ar = 200                    # Archiving & PROPA_FISS call step
tfin = tdyn+nbpady*deltat       # Final time
deltar = (tfin-tdyn)/nbpas_ar   # Implicit function time-steps
#instfin = [1.1e-5,1.2e-5,1.3e-5,1.4e-5,1.5e-5,tfin]        # list propagation INSTS
#instfin = [1.1e-5,1.15e-5,1.2e-5,1.25e-5,1.3e-5,1.35e-5,1.4e-5,1.45e-5,1.5e-5,1.55e-5,1.6e-5,1.65e-5,1.7e-5,1.75e-5,1.8e-5,1.85e-5,1.9e-5,1.95e-5,tfin]        # list propagation INSTS
instfin = [1.1e-5,1.5e-5,2.0e-5,2.5e-5,3.0e-5,3.1e-5,3.2e-5,3.3e-5,3.4e-5,3.5e-5,3.6e-5,3.7e-5,3.8e-5,3.9e-5,4e-5,4.1e-5,4.2e-5,4.3e-5,4.4e-5,4.5e-5,4.6e-5,4.7e-5,tfin]
nbcalc = len(instfin)

# Maximum Macro-crack extension for PROPA_FISS step
da_max=20.

# Initial Crack Angle
angle=0.      # The intial crack angle must match in dynamics!
nb_pts=2.     # Number of elements along crack front
h_min=1.0
int_nb_cracks = 2 # Intial number of cracks
Prop_len=5#0.88*((Gc*young)/((Sc*Sc)*(1-(poiss*poiss)))) # Estimation of static cohesive zone size



#----------------------------------------------------------------------#
#                PHASE 1 - LOADING for S just above Sc                 #
#              other approach is to linearly extrapolate               #
#----------------------------------------------------------------------#


'''
print "\n #===========================================================# \n"
print "   PHASE 1 - LOADING for S just above Sc"
print "\n #===========================================================# \n"


S=0           # Intialising stress test as below Sc 
sl=[]         # List of stresses throught loading increment
while (S <Sc):		
	MAIL=LIRE_MAILLAGE(FORMAT='MED',);

	MAIL = DEFI_GROUP(reuse =MAIL,
		   MAILLAGE = MAIL,
		   CREA_GROUP_MA = (
			  _F(NOM = 'FACE_SUP', GROUP_MA = 'GM123'),
			  _F(NOM = 'FACE_INF', GROUP_MA = 'GM124'),
			  _F(NOM = 'FONDINI_0', GROUP_MA = 'GM125'),
			  _F(NOM = 'FONDINI_1', GROUP_MA = 'GM125_1'),          
			  _F(NOM = 'LIG_HAUT', GROUP_MA = 'GM126'),
			  _F(NOM = 'LIG_LAT' , GROUP_MA = 'GM127'),
			  _F(NOM = 'VOLUME' , GROUP_MA = 'GM128'),
		   ),
		   CREA_GROUP_NO = (
			  _F(GROUP_MA = 'LIG_HAUT'),
			  _F(GROUP_MA = 'LIG_LAT'),
			  _F(NOM = 'c1' , GROUP_MA = 'FONDINI_0'),
			  _F(NOM = 'c2' , GROUP_MA = 'FONDINI_1'),          
			 )
		   );

	MA=DEFI_MATERIAU(ELAS = _F(E = young,
									NU = poiss,
									RHO = rho),
										 );     

	MAIL=MODI_MAILLAGE(reuse=MAIL,
					   MAILLAGE=MAIL,
					   ORIE_PEAU_3D=_F(GROUP_MA=('FACE_SUP','FACE_INF'),),
					   );

	MODE=AFFE_MODELE(MAILLAGE=MAIL,
					 AFFE=_F(TOUT='OUI',
							 PHENOMENE='MECANIQUE',
							 MODELISATION='3D',),);

	MATE=AFFE_MATERIAU(MAILLAGE=MAIL,
					   AFFE=_F(TOUT='OUI',
							   MATER=MA,),);



	CHAR=AFFE_CHAR_MECA(MODELE=MODE,
					  PRES_REP=(_F(GROUP_MA='FACE_INF',
												 PRES=-pressures,),
											  _F(GROUP_MA='FACE_SUP',
												 PRES=-pressures,),),
					  DDL_IMPO = (_F(GROUP_NO='LIG_HAUT', DY = 0.0, DZ = 0.0),
											_F(GROUP_NO='LIG_LAT', DX = 0.0, DY = 0.0),),
						);
						
	L_INST=DEFI_LIST_REEL(DEBUT=0.0,
						  INTERVALLE=_F(JUSQU_A=1,NOMBRE=1,),);
						  
	DEFLIST =DEFI_LIST_INST(DEFI_LIST=_F(LIST_INST = L_INST,),)

		 
	RESU=STAT_NON_LINE(MODELE=MODE,
					   CHAM_MATER=MATE,
					   EXCIT=(_F(CHARGE=CHAR,),),
					   COMPORTEMENT = (_F(RELATION = 'ELAS',),),
					   INCREMENT=_F(LIST_INST=DEFLIST,
					   ),);             
					   

	RESU=CALC_CHAMP(reuse=RESU,
				   RESULTAT=RESU,
				   CONTRAINTE=('SIGM_ELNO','SIGM_NOEU','SIGM_ELGA',),
				   CRITERES=('SIEQ_ELNO','SIEQ_NOEU',),);
				   
	#IMPR_RESU(FORMAT='MED',
 	 #        RESU=_F(RESULTAT=RESU),);
 	         
	#IMPR_RESU(FORMAT='RESULTAT',
	#		  #UNITE=10,
	#		  RESU=_F(RESULTAT=RESU,
	#				  NOM_CHAM='SIGM_NOEU',
	#				 # NOM_CMP=('SIXX','SIYY',),
	#				  GROUP_NO=('c1'),
	#				  IMPR_COOR='OUI',
	#				  INST=1.0,
	#				  ),);    
					  
	TAB_U=[None]*int_nb_cracks 
	for r in range(int_nb_cracks):
		R=r+1

		TAB_U[r] = POST_RELEVE_T(ACTION = _F(INTITULE   = 'STRESS',
									  RESULTAT   =  RESU,
									  OPERATION  = 'MOYENNE_ARITH', # average
									  NOM_CHAM   = 'SIGM_NOEU',
									  TOUT_CMP= 'OUI',
									 # NOM_CMP    = 'SIYY',
									  GROUP_NO   = 'c%d'%R,
									  INST=1.0,
									 ),);
		IMPR_TABLE(TABLE=TAB_U[r]);									 
		tmp=TAB_U[r].EXTR_TABLE().values()
		STRESS=tmp['MOYENNE'] #Print the average of the stress at the crack front
		print STRESS
		S=max(STRESS)	
		sl.append(S) # List of max stresses reached at each step
		#DETRUIRE(CONCEPT=_F(NOM=TAB_U),INFO=1);	
		#DETRUIRE(CONCEPT=_F(NOM=STRESS),INFO=1);
			
	# Need to seperate each crack ... List of max(s)	
	if(S <Sc) or (S > Sc):
		DIFF = Sc/S
		print DIFF
		pressures=pressures*DIFF+(Sc/percential) # Linearly extrapolates and adds 1%
		pressured=pressures                      # For static loading
	
	DETRUIRE(CONCEPT=_F(NOM=MA),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=MAIL),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=MODE),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=MATE),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=CHAR),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=L_INST),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=DEFLIST),INFO=1);
	DETRUIRE(CONCEPT=_F(NOM=RESU),INFO=1);
	for r in range(int_nb_cracks):	
		DETRUIRE(CONCEPT=_F(NOM=TAB_U[r]),INFO=1);
print"\n =========================================================== \n"
print "   PHASE 2 CRITICAL LOADING SUMMARY \n"
print 'All tested Stresses = '+str(sl)
print ' '
print 'Critical Loading = '+str(pressured-(Sc/percential))				
print 'Super Critical Loading = '+str(pressured)
print ' '
for r in range(int_nb_cracks):
	print 'Max stress reached crack_'+str(int_nb_cracks-r)+' = '+str(sl[-r-1])
print"\n =========================================================== \n"		
'''



	
#----------------------------------------------------------------------#
#                 PHASE 2 - Multiple crack Propagation                 #
#                                                                      #
#----------------------------------------------------------------------#



print "\n #===========================================================# \n"
print "   PHASE 2 - Multiple crack Propagation"
print "\n #===========================================================# \n"

# Reading mesh 
MA1 = LIRE_MAILLAGE(FORMAT='MED');
MA =  COPIER(CONCEPT= MA1);

# Defineing groups from mesh. (Easier for transferable codes)
MA = DEFI_GROUP(reuse = MA,
       MAILLAGE = MA,
       CREA_GROUP_MA = (
          _F(NOM = 'FACE_SUP', GROUP_MA = 'GM123'),
          _F(NOM = 'FACE_INF', GROUP_MA = 'GM124'),
          _F(NOM = 'FONDINI_0', GROUP_MA = 'GM125'),
          _F(NOM = 'FONDINI_1', GROUP_MA = 'GM125_1'),          
          _F(NOM = 'LIG_HAUT', GROUP_MA = 'GM126'),
          _F(NOM = 'LIG_LAT' , GROUP_MA = 'GM127'),
          _F(NOM = 'VOLUME' , GROUP_MA = 'GM128'),
       ),
       CREA_GROUP_NO = (
          _F(GROUP_MA = 'LIG_HAUT'),
          _F(GROUP_MA = 'LIG_LAT'),
         )
       );

# Applying mesh to model (defining vectors)
MO = AFFE_MODELE(MAILLAGE = MA,
			     AFFE =_F(GROUP_MA = ('VOLUME','FACE_SUP','FACE_INF'),
				          PHENOMENE    = 'MECANIQUE',
				          MODELISATION = '3D'),);
         
# Defining Material
BETON = DEFI_MATERIAU(ELAS = _F(E = young,
                                NU = poiss,
                                RHO = rho),
                      RUPT_FRAG = _F(GC = Gc,
                                     SIGM_C = Sc,
                                     PENA_LAGR=pena_lag, ),);     
                                     

L_FOND=[]
SIFIN = [None]*int_nb_cracks
# Number of Crack fronts str list

for i in range(int_nb_cracks):
	# List of crack front str
	L_FOND.append(str('FONDINI_'+str(i)))
                       
	SIFIN[i]=CREA_TABLE(LISTE=(_F(LISTE_R=(0.,1.),PARA='ABSC_CURV'),
    	                    _F(LISTE_R=(1.,1.),PARA='K1'),
        	                _F(LISTE_R=(0.,0.),PARA='K2'),
                      	    _F(LISTE_R=(0.,0.),PARA='K3'),
                      	    _F(LISTE_R=(1.,1.),PARA='G'),
                      	    _F(LISTE_R=(angle,angle),PARA='BETA'),
                        	_F(LISTE_R=(1.,1.),PARA='G_IRWIN'),
                    	    _F(LISTE_I=(1,1),PARA='NUME_FOND'),
                	        _F(LISTE_I=(1,1),PARA='NUME_ORDRE'),
            	            _F(LISTE_I=(1,2),PARA='NUM_PT'),));
#-----------------------------------------------------------------------                                   
# Defineing XFEM cracks 
#-----------------------------------------------------------------------

# CRACK 1
FISIN=DEFI_FISS_XFEM(MODELE=MO,
                     TYPE_DISCONTINUITE='COHESIF',
                     DEFI_FISS=_F(FORM_FISS = 'DEMI_PLAN',
                                  PFON      =(0. , 50., 0.),
                                  NORMALE   =(0. , 0., 1.),
                                  DTAN      =(0. , 1., 0.),
                                  FRONT_INI  = str(L_FOND[0]),),
                     GROUP_MA_ENRI='VOLUME',
                     );

# CRACK 2
FISIN2=DEFI_FISS_XFEM(MODELE=MO,
                     TYPE_DISCONTINUITE='COHESIF',
                     DEFI_FISS=_F(FORM_FISS = 'DEMI_PLAN',
                                  PFON      =(0. , 150., 0.),
                                  NORMALE   =(0. , 0., 1.),
                                  DTAN      =(0. , -1., 0.),
                                  FRONT_INI  = L_FOND[1],),
                     GROUP_MA_ENRI='VOLUME',
                     );

# List intial XFEM cracks 
L_Int_Crack=[FISIN,FISIN2]

#----------------------------------------------------------------------- 
# Intial crack detection
#-----------------------------------------------------------------------
# intialising list of lists needs for loop of list objects
FISS = [[None]*(nbcalc+1) for ii in range(int_nb_cracks)]     # FISS list for each crack
FISP = [[None]*(nbcalc+1) for ii in range(int_nb_cracks)]     # FISS propagation list for each crack
SIF = [[None]*(nbcalc+1) for ii in range(int_nb_cracks)]      # SIF calculation min(value)
SIF_AT=[[None]*(nbcalc+1) for ii in range(int_nb_cracks)]     # SIF TABLE List for each crack
dD_A=[0]*int_nb_cracks                                        # Propagation length for PN_FISS
Prop_sum=[]                                                   # Propagation Summary blurb
print "FISS - "
print FISS
# FISQ (quasi-static) is now FISS[0]
# LIST construction(quasi-static and dynamic) - FISS[quasi,dyn]*nbcalc
# FISQ is necessary cause data structure is enriched if CONTACT='OUI'
# and that would cause the dynamic code to crash if we were to reuse the same object
for j in range(int_nb_cracks):
	# Quasi-static 
	F = "C_"+str(0)+"_"+str(j)+"_"+str(0) 
	PROPA_FISS(MODELE=MO,
			   METHODE_PROPA='COHESIVE',
			   CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
			   ZONE_MAJ='TOUT',
			   TEST_MAIL='NON',
			   FISSURE=_F(FISS_ACTUELLE=FISIN,
						  FISS_PROPAGEE=CO(F),
						  NB_POINT_FOND=nb_pts,
						  TABLE=SIFIN[0],),
			   DA_MAX=da_max,
			   INFO=1,);
	FISS[0][j] = eval(F)
	print 'j is %d'%j
			   
	# split for data structure, to avoid a fake enriched model		 
	# Dynamic
	FF = "C_"+str(1)+"_"+str(j)+"_"+str(0) 	 
	PROPA_FISS(MODELE=MO,
			   METHODE_PROPA='COHESIVE',
			   CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
			   ZONE_MAJ='TOUT',
			   TEST_MAIL='NON',
			   FISSURE=_F(FISS_ACTUELLE=FISIN2,
						  FISS_PROPAGEE=CO(FF),
						  NB_POINT_FOND=nb_pts,
						  TABLE=SIFIN[1],),
			   DA_MAX=da_max,
			   INFO=1,);
	FISS[1][j] = eval(FF)

#----------------------------------------------------------------------- 
# TIME SCHEME - QUASI- STATIC
#----------------------------------------------------------------------- 	
      
# Loading ramp funtcion - QUASI-STATIC
TRACT_T=DEFI_FONCTION(NOM_PARA='INST',
    	              VALE= (0.  , 0.,
                             tdyn, 1.),
                      PROL_DROITE='LINEAIRE',
                      PROL_GAUCHE='LINEAIRE'
                      );

# INST list - INTIAL QUASI-STATIC
INSTANTS = DEFI_LIST_REEL(DEBUT = 0.,
                          INTERVALLE = (_F(JUSQU_A = tdyn, #tdyn = time where dynamic starts
                                           NOMBRE = nbpas),), #nbpas = 1
                          );

# ARCHIVING LIST  - INITIAL QUASI-STATIC
# basically the same as the above
INS_ARCH = DEFI_LIST_REEL(DEBUT = 0.,
                          INTERVALLE = (_F(JUSQU_A =  tdyn, 
                                           NOMBRE = nbpas),),
                          );
#----------------------------------------------------------------------- 
# TIME SCHEME - DYNAMIC
#----------------------------------------------------------------------- 
# Ramp function for dynamic and static propagation until tfin
TRACT_X=DEFI_FONCTION(NOM_PARA='INST',
    	                VALE= (0.  , 0.,
                             tdyn, 1.,
                             tfin, 1.),
                      PROL_DROITE='LINEAIRE',
                      PROL_GAUCHE='LINEAIRE'
                      );

# INST LIST QUASI-STATIC & DYNAMIC
INSTANTX = DEFI_LIST_REEL(DEBUT = 0.,
                          INTERVALLE = (_F(JUSQU_A = tdyn, 
                                           NOMBRE = nbpas),
                                        _F(JUSQU_A = tfin,
                                           NOMBRE = nbpady,),),);
                          
# ARCHIVING LIST - QUASI-STATIC & DYNAMIC
INS_ARCX = DEFI_LIST_REEL(DEBUT = 0.,
                          INTERVALLE = (_F(JUSQU_A =  tdyn, 
                                           NOMBRE = nbpas),
                                        _F(JUSQU_A = tfin,
                                           NOMBRE = nbpas_ar,),),);

# archiving times list, except for last time step                          
INS_AR = DEFI_LIST_REEL(DEBUT = tdyn+deltar,
                        INTERVALLE = (_F(JUSQU_A = tfin,
                                         NOMBRE = nbpas_ar-1,),),);             

#----------------------------------------------------------------------- 
# INTITAL PROPAGATION - QUASI- STATIC
#----------------------------------------------------------------------- 
             
# lists for loops
EVOL = [None]*nbcalc
RIGID = [None]*nbcalc
TRACI = [None]*nbcalc
CHAMM = [None]*nbcalc
MODX = [None]*nbcalc


# For loop over time steps
for i in range(nbcalc):
    if(i>=4):
        da_max= 5
        
    #-----------------------------------------------------------------------#-----------------------------------------------------------------------
    print "#-----------------------------------------------------------"
    print "   Propagation_" + str(i)
    print "#-----------------------------------------------------------"
    # Intial crack argument

    print "FISS - "+str(FISS)
    crack_arg = tuple([sublist[0] for sublist in FISS])
    print "Crack Argument - " +str(crack_arg)
    MODK=MODI_MODELE_XFEM(MODELE_IN=MO,
                          FISSURE=crack_arg,
                          CONTACT='OUI',);
     
    CTX = DEFI_CONTACT(MODELE= MODK, # Defining contact for new model
                       FORMULATION    = 'XFEM',
                       FROTTEMENT     = 'SANS',
                       ITER_CONT_MAXI = 3,
                       ZONE=(_F(INTEGRATION='GAUSS',
                                ORDRE_INT=4,
                                ALGO_CONT='CZM',
                                FISS_MAIT = FISS[0][0],
                                ALGO_LAGR='VERSION2',
                                RELATION='CZM_LIN_REG',
                                ),
                            _F(INTEGRATION='GAUSS', # Doubled
                                ORDRE_INT=4,
                                ALGO_CONT='CZM',
                                FISS_MAIT = FISS[1][0],
                                ALGO_LAGR='VERSION2',
                                RELATION='CZM_LIN_REG',)));

    CHAMPMA=AFFE_MATERIAU(MAILLAGE=MA, # Applying material to model
                          MODELE=MODK,
                          AFFE=(_F(GROUP_MA='VOLUME',MATER=BETON),),);


    RIGIDE = AFFE_CHAR_MECA(MODELE   = MODK, # BC's for rigid body
                            DDL_IMPO = (_F(GROUP_NO='LIG_HAUT', DX = 0.0, DY = 0.0, DZ = 0.0),
                                        _F(GROUP_NO='LIG_LAT', DX = 0.0, DY = 0.0, DZ = 0.0),),);
                           
    TRACTION = AFFE_CHAR_MECA(MODELE = MODK, # BC's for loading body
                               PRES_REP=(_F(GROUP_MA='FACE_INF',
                                             PRES=-pressures,),
                                          _F(GROUP_MA='FACE_SUP',
                                             PRES=-pressures,),),);

    EVOL[i] = STAT_NON_LINE(MODELE = MODK,# STAT_NON_LINE intial
                            CHAM_MATER = CHAMPMA,
                            CONTACT = CTX,
                            EXCIT = (_F(CHARGE = RIGIDE),
                                     _F(CHARGE = TRACTION,
                                        FONC_MULT = TRACT_T),
                                     ),
                            COMPORTEMENT = (_F(RELATION = 'ELAS', 
                                               GROUP_MA = 'VOLUME'),
                                           ),
                            INCREMENT = _F(LIST_INST = INSTANTS,
                                           INST_FIN = tdyn,
                                           PRECISION=1.E-9,),
                            NEWTON  = _F(REAC_ITER = 1),
                            CONVERGENCE = _F(RESI_GLOB_RELA = 1.E-6,
                                             ITER_GLOB_MAXI = 10),
                            SOLVEUR    = _F(METHODE = 'MUMPS',
                                            NPREC=-1,),
                            ARCHIVAGE = _F(LIST_INST = INS_ARCH,
                                           PRECISION=1.E-15,
                                           CHAM_EXCLU='VARI_ELGA'));

    # Create field from previous propgation to project
    CH1= CREA_CHAMP (OPERATION= 'EXTR',
                     TYPE_CHAM='NOEU_DEPL_R',
                     RESULTAT= EVOL[i], 
                     NOM_CHAM= 'DEPL',
                     PRECISION = 1.E-9,
                     INST = tdyn);

    CH2= CREA_CHAMP (OPERATION= 'EXTR' ,
                     TYPE_CHAM='ELGA_SIEF_R',
                     RESULTAT= EVOL[i],
                     NOM_CHAM= 'SIEF_ELGA',
                     PRECISION = 1.E-9,
                     INST = tdyn);
                 
    #----------------------------------------------------------------------- 
    # PROPAGATION - DYNAMIC
    #----------------------------------------------------------------------- 
                 
    # index (i+1) cause index 0 is quasi static (former FISQ)
    crack_arg = tuple([sublist[i+1] for sublist in FISS])
    print "Crack Argument - "+str(crack_arg)

    MODX[i]=MODI_MODELE_XFEM(MODELE_IN=MO,
                             FISSURE=crack_arg,
                             CONTACT='NON',);

    CHAMM[i]=AFFE_MATERIAU(MAILLAGE=MA,# New model - Asign material
                             MODELE=MODX[i],
                             AFFE=(_F(GROUP_MA='VOLUME',MATER=BETON),),);

    RIGID[i] = AFFE_CHAR_MECA(MODELE   = MODX[i],# New model - BC's Rigid body 
                               DDL_IMPO = (_F(GROUP_NO='LIG_HAUT', DX = 0.0, DY = 0.0, DZ = 0.0),
                                           _F(GROUP_NO='LIG_LAT', DX = 0.0,  DY = 0.0, DZ = 0.0),),);

    TRACI[i] = AFFE_CHAR_MECA(MODELE = MODX[i],# New model - Applying loadings
                                  PRES_REP=(_F(GROUP_MA='FACE_INF',
                                             PRES=-pressured,),
                                          _F(GROUP_MA='FACE_SUP',
                                             PRES=-pressured,),),);

    if(i!=(nbcalc-1)):# Applying dynamic calculation IF not last step
       EVOL[i]=DYNA_NON_LINE(reuse=EVOL[i],
                             ETAT_INIT  = _F(DEPL = CH1, SIGM=CH2,),
                             MODELE     = MODX[i],
                             CHAM_MATER = CHAMM[i],
                             MASS_DIAG  = 'OUI',
                             EXCIT      = (_F(CHARGE = RIGID[i]),
                                           _F(CHARGE = TRACI[i],
                                              FONC_MULT = TRACT_X),
                                           ),
                            COMPORTEMENT = (_F(RELATION = 'ELAS', 
                                               GROUP_MA = 'VOLUME'),
                                           ),
                            INCREMENT  = _F(LIST_INST = INSTANTX,
                                            INST_INIT = tdyn,
                                            INST_FIN = instfin[i],
                                            PRECISION = 1.E-9),
                            SCHEMA_TEMPS=_F(SCHEMA='DIFF_CENT',
                                            FORMULATION='ACCELERATION',
                                            STOP_CFL = 'NON'),
                            CONVERGENCE= _F(ITER_GLOB_MAXI = 50),
                            NEWTON     = _F(MATRICE = 'TANGENTE',
                                            REAC_ITER=1),
                            ARCHIVAGE = _F(INST = instfin[i],
                                           PRECISION=1.E-15,)
                            );
                            
       EVOL[i] = EXTR_RESU(reuse=EVOL[i], # Restrict to result (recover)
                           RESULTAT=EVOL[i],
                           ARCHIVAGE=_F(INST=instfin[i],
                                        PRECISION=1.E-9),);										
                                        
	#--------------------------------------------------------------------#
	#                       TEST IF TO PROPAGATE N CRACKS
	#--------------------------------------------------------------------#
       GG=[]                     # Pythonic table for ADVS		   
       TAB=[]                    # Pythonic table for ADV	   
       A_FISS = []               # Arrested cracks
       P_FISS = []               # cracks to propagate 
       N_FISS = [] # cracks NOT to propagate (G=0 ... arrested)
       PN_FISS= [] # cracks NOT to propagate (da< 5*h_min not beyond CZ)
       P_name=[]   # names of cracks to propagate
       N_name=[]   # names of cracks NOT to proagate (G=0)
       PN_name=[]  # names of cracks NOT to proagate (da< 5*h_min)
       ADVS=[None]*int_nb_cracks # List to test for arrest
       SIFF=[None]*int_nb_cracks # list of sif to add to SIF[][]
       ADV=[None]*int_nb_cracks  # List to test (da< 5*h_min)
       
       for k in range(len(FISS)): # Testing each crack in int crack lists
           
           F_S = "C_"+str(k)+"_"+str(0)+"_"+str(i) # Static crack
           F_D = "C_"+str(k)+"_"+str(1)+"_"+str(i) # Dynamic crack
           F_P = "P_"+str(k)+"_"+str(1)+"_"+str(i) # Propagating crack      
           print "   Quasi-static Crack - "+str(F_S)
           print "   Dynamic Crack - "+str(F_D)
           print "\n   ***Testing FISS " + str(F_D) + " *** \n"
       
    #--------------------------------------------------------------------------------#  		   
           print "\n   *** DECISION- 1 of 3 - Intiated or arrested? *** \n"
    #--------------------------------------------------------------------------------#		   
           if(i==0): # First Step
               ADVS[k]=CALC_G(RESULTAT=EVOL[i],
                          OPTION='K_G_COHE',
                          INST=instfin[i],
                          THETA=_F(FISSURE=eval(F_D),
                                   NUME_FOND=1,
                                   NB_POINT_FOND=nb_pts,
                                       R_SUP=h_min*10,
                                       R_INF=h_min*5), # R_INF is a dummy value, not used for cohesive
                          LISSAGE=_F(LISSAGE_THETA='LAGRANGE',
                                     LISSAGE_G='LAGRANGE_NO_NO',),
                          PRECISION=1.E-15,);

               tmp=ADVS[k].EXTR_TABLE().values()
               G=tmp['G']
               SIF_AT[k][i+1]=ADVS[k]		   
               GG=min(G)			   
               print GG				   
               DETRUIRE(CONCEPT=_F(NOM=ADVS[k]),INFO=1);
               
           if(i>=1): # All steps after	   
               if(eval(F_D) in N_FISS): # Cracks that havent intiated yet 
                   print "\n FISS "+str(F_D) + " is in N_FISS \n"  
                   ADVS[k]=CALC_G(RESULTAT=EVOL[i],
                          OPTION='K_G_COHE',
                          INST=instfin[i],
                          THETA=_F(FISSURE=eval(F_D),
                                   NUME_FOND=1,
                                   NB_POINT_FOND=nb_pts,
                                       R_SUP=h_min*10,
                                       R_INF=h_min*5), # R_INF is a dummy value, not used for cohesive
                          LISSAGE=_F(LISSAGE_THETA='LAGRANGE',
                                     LISSAGE_G='LAGRANGE_NO_NO',),
                          PRECISION=1.E-15,);

                   print "SIFF_AT = "+ str(SIF_AT)		   
                   tmp=ADVS[k].EXTR_TABLE().values()
                   G=tmp['G'] 
                   SIF_AT[k][i+1]=ADVS[k]		   	
                   GG=min(G)
                   print GG
                   DETRUIRE(CONCEPT=_F(NOM=ADVS[k]),INFO=1);		
                                                  
               elif(eval(F_D) in A_FISS):
                   print "\n FISS "+str(F_D) + " is in A_FISS \n"
                   print "SIFF = "+ str(SIF)
                   print "SIFF_AT = "+ str(SIF_AT) 				     
                   tmp=SIF[k][i]
                   GG=tmp				   
                   print GG						   

               elif(eval(F_D) in PN_FISS):
                   print "\n FISS "+str(F_D) + " is in PN_FISS \n" 
                   print "SIFF = "+ str(SIF)
                   print "SIFF_AT = "+ str(SIF_AT) 				    
                   tmp=SIF[k][i]
                   GG=tmp				   		   
                   print GG			
               
               else:#(eval(F_D) in P_FISS): 
                   print "\n FISS "+str(F_D) + " is in P_FISS \n" 
                   print "SIFF = "+ str(SIF) 
                   print "SIFF_AT = "+ str(SIF_AT)
                   tmp=SIF[k][i]
                   GG=tmp
                   print GG			   

    #-----------------------------    DECISION 1 - What do do?   -------------------------#	

           if (GG==0): # is the lowest value 0, add elif if want tot use A_FISS
               N_FISS.append(eval(F_D)) # Populate not propagating list FISS[k][1+i]
               N_name.append(str(F_D))
               SIF[k][i+1]=SIF[k][i]    # Store SIF (for consitency) for next propagation
               print "\n   *** DECISION - 1 RESULT *** \n"
               print "\n   FISS "+str(F_D) + " has not intiated as G = "+str(GG)+" therefore len(NFISS) = "+str(len(N_FISS))+"\n"           
               print "\n   Memory location: "+str(N_FISS)
               
           else:
               print "\n   *** DECISION - 1 RESULT *** \n    "
               print "\n   "+ str(F_D) + " has intiated/re-started" 
               print "   G = " + str(GG)  
               print "\n   Moving on to DECISION 2    \n"     

    #---------------------------------------------------------------------------------#  		   
           print "\n   *** DECISION - 2 of 3 - Propgated beyond far enough (beyond cohesive zone)? *** \n"
    #---------------------------------------------------------------------------------#	
           FISP[k][i] = CO(F_P) # Assigning crack to list	   
           if(i==0) and (eval(F_D) not in N_FISS):
               print "\n    DECISION 2: (i==0) and (" + str(F_D)+" not in N_FISS) = PROPAGATE!"
               ADV[k]= PROPA_FISS(MODELE=MODX[i],
                               METHODE_PROPA='DETECTION',
                               RESULTAT=EVOL[i],
                               ZONE_MAJ='TOUT',
                               TEST_MAIL='NON',
                               FISSURE=(_F(FISS_ACTUELLE=FISS[k][1+i],
                                          FISS_PROPAGEE=FISP[k][i],
                                              NB_POINT_FOND=nb_pts,
                                          TABLE=SIFIN[k],), # Intial table
                                          ),
                               INFO=1,);

               IMPR_TABLE(TABLE=ADV[k],TITRE=' CRACK_'+ str(k) + '\n Time ' + str(instfin[i]),)
               tab = ADV[k].EXTR_TABLE().values() # Convert table to python (PAR_LOT= 'NON')
               TAB=tab['CRACK0']                  # Accesses aster table
               print TAB                          # Prints table to mess file		
               DETRUIRE(CONCEPT=_F(NOM=ADV[k]),INFO=1);	# Destorys aster table
                    
                    
           elif (i>0) and (eval(F_D) not in N_FISS) and (eval(F_D) not in A_FISS):
               print "\n    DECISION 2: (i>0) and ("+ str(F_D)+" not in N_FISS or A_FISS)= PROPAGATE!" 
               # So, if in P_FISS or PN_FISS propagate!
               ADV[k]= PROPA_FISS(MODELE=MODX[i],
                               METHODE_PROPA='DETECTION',
                               RESULTAT=EVOL[i],
                               ZONE_MAJ='TOUT',
                               TEST_MAIL='NON',
                               FISSURE=(_F(FISS_ACTUELLE=FISS[k][1+i],
                                          FISS_PROPAGEE=FISP[k][i],
                                              NB_POINT_FOND=nb_pts,
                                          TABLE=SIF_AT[k][i],), # Created by previous step
                                          ),
                               INFO=1,);	
               # Prints table to resu file
               IMPR_TABLE(TABLE=ADV[k],TITRE=' CRACK_'+ str(k) + '\n Time ' + str(instfin[i]),)
               tab = ADV[k].EXTR_TABLE().values()       # Convert table to python (PAR_LOT= 'NON')
               TAB=tab['CRACK0']
               print TAB                                # Prints table to mess file
               DETRUIRE(CONCEPT=_F(NOM=ADV[k]),INFO=1); # Destroys aster table 
           else:
               print "\n   In N_FISS not conducting DECISION 2  \n"	
               tab=[]# over-write tab						   

    #-----------------------------    DECISION 2 - What do do?   -------------------------#       
           if(eval(F_D) in N_FISS): # If G=0 then it will be in N_FISS    
               print "\n   DECISION 2 not conducted... reusing previous SIF"
               #---------------------------------------------------#
               if(i!=0):
                   DETRUIRE(CONCEPT=_F(NOM=SIF_AT[k][i]),INFO=1);
               #---------------------------------------------------#
               # Calculating SIF for cracks not arrested but not propagated far enough
               SIFF[k]=CALC_G(RESULTAT=EVOL[i],
                              OPTION='K_G_COHE',
                              INST=instfin[i],
                              THETA=_F(FISSURE=eval(F_D),#PN_FISS[k],#
                                       NUME_FOND=1,
                                       NB_POINT_FOND=nb_pts,
                                       R_SUP=h_min*10,
                                       R_INF=h_min*2), # R_INF is a dummy value, not used for cohesive
                              LISSAGE=_F(LISSAGE_THETA='LAGRANGE',
                                         LISSAGE_G='LAGRANGE_NO_NO',),);
                                                 
               IMPR_TABLE(TABLE=SIFF[k],UNITE=6,);
               print SIFF[k]

               IMPR_TABLE(TABLE=SIFF[k],UNITE=8,);			   
               tmp=SIFF[k].EXTR_TABLE().values()
               GG=tmp['G'] 
               SIF_AT[k][i+1]=SIFF[k]			   
               G=min(GG) 			   
               SIF[k][i+1]=G   # Store SIF (for consitency) for next propagation			   
               print "   min G = "+ str(GG)
               print "   SIF["+str(k)+"]["+str(i)+"+1] = " 
               print SIF[k][i+1]		               
           else:
               print "\n   Not in N_FISS"
               dD_A[k]=dD_A[k]+min(TAB) # sum(Propagation length) over i
               print"\n   Propagation length (dD_A) = " + str(dD_A[k]) + " of crack " + str(F_P)
               if (dD_A[k]>Prop_len) and (GG!=0):
                   print "\n   Propagation length > " + str(Prop_len)
                   dD_A[k]=0 # Reset prop_length sum counter 
                   P_FISS.append(FISP[k][i]) # Add crack to list to propagation
                   print "\n   Adding crack "+str(F_P)+" to P_FISS \n"			                   	
                   print P_FISS
                   print FISP[k][i]
                   P_name.append(str(F_P))
                   print "\n   Calculating new SIF for crack "+str(F_P)	
                   #---------------------------------------------------#
                   if(i!=0):# Destroys aster table after first rotation
                       DETRUIRE(CONCEPT=_F(NOM=SIF_AT[k][i]),INFO=1); 
                   #---------------------------------------------------#        
                                  
                   # Calculating SIF for cracks that have propagated far enough
                   SIFF[k]=CALC_G(RESULTAT=EVOL[i],
                              OPTION='K_G_COHE',
                              INST=instfin[i],
                              THETA=_F(FISSURE=eval(F_P),#P_FISS[k],
                                       NUME_FOND=1,
                                       NB_POINT_FOND=nb_pts,
                                       R_SUP=h_min*10,
                                       R_INF=h_min*2), # R_INF is a dummy value, not used for cohesive
                              LISSAGE=_F(LISSAGE_THETA='LAGRANGE',
                                         LISSAGE_G='LAGRANGE_NO_NO',),);
                   print SIFF[k]
                                             
                   IMPR_TABLE(TABLE=SIFF[k],UNITE=6,);
                   tmp=SIFF[k].EXTR_TABLE().values()
                   GG=tmp['G'] 
                   SIF_AT[k][i+1]=SIFF[k]				   
                   G=min(GG) 			   
                   SIF[k][i+1]=G   # Store SIF (for consitency) for next propagation
                   IMPR_TABLE(TABLE=SIFF[k],UNITE=8,); # Prints to mess file
                   print "   min G = "+ str(GG)
                   print "   SIF["+str(k)+"]["+str(i)+"+1] = "+str(SIF[k][i+1])           

               else:# (eval(F_D) not in P_FISS):
                   dD_A[k]=dD_A[k]+min(TAB) # Counter for length
                   print "\n   Propagation length < " + str(Prop_len)
                   print "\n   Adding crack "+str(F_P)+" to PN_FISS \n"		   
                   PN_FISS.append(FISP[k][i]) # Add crack to list NOT to propagation
                   PN_name.append(str(F_P))
                   
                   #---------------------------------------------------#
                   if(i!=0):
                       DETRUIRE(CONCEPT=_F(NOM=SIF_AT[k][i]),INFO=1); 
                   #---------------------------------------------------#                       
                   print "\n   Calculating new SIF for crack "+str(F_P)	                       
                   # Calculating SIF for cracks not arrested but not propagated far enough
                   SIFF[k]=CALC_G(RESULTAT=EVOL[i],
                              OPTION='K_G_COHE',
                              INST=instfin[i],
                              THETA=_F(FISSURE=eval(F_P),#PN_FISS[k],#
                                       NUME_FOND=1,
                                       NB_POINT_FOND=nb_pts,
                                       R_SUP=h_min*10,
                                       R_INF=h_min*2), # R_INF is a dummy value, not used for cohesive
                              LISSAGE=_F(LISSAGE_THETA='LAGRANGE',
                                         LISSAGE_G='LAGRANGE_NO_NO',),);
                                                 
                   IMPR_TABLE(TABLE=SIFF[k],UNITE=6,);
                   IMPR_TABLE(TABLE=SIFF[k],UNITE=8,);		
                   print SIFF[k]	   
                   tmp=SIFF[k].EXTR_TABLE().values()
                   GG=tmp['G'] 
                   SIF_AT[k][i+1]=SIFF[k]			   
                   G=min(GG) 			   	   
                   SIF[k][i+1]=G   # Store SIF (for consitency) for next propagation			   
                   print "   min G = "+ str(GG)
                   print "   SIF["+str(k)+"]["+str(i)+"+1] = " +str(SIF[k][i+1])               
                   
    #---------------------------------------------------------------------------------#  		   
           print "\n   *** DECISION- 3 of 3 - Propagate cracks *** \n"
    #---------------------------------------------------------------------------------#	
                      
           if(eval(F_P) in P_FISS): # Only Propagate cracks if list populated
                        
               print "\n   P_FISS is populated with crack: "+str(F_P) 
               
               ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1)           
               print "\n   Creating new quasi-static crack " +str(ff)        
               crack_arg = tuple(P_FISS)
               DUMMOD=MODI_MODELE_XFEM(MODELE_IN=MO,
                                    FISSURE=eval(F_P),
                                    CONTACT='NON',);		 
               # q-static
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_P),#P_FISS[k], # This has been propagated
                                  FISS_PROPAGEE=CO(ff),
                                  NB_POINT_FOND=nb_pts,
                                  TABLE=SIFF[k],),
                      DA_MAX=da_max,
                      INFO=1,);
            
               FISS[k][0] = eval(ff) # FISS[0][0],FISS[0][1] always q-static
               print FISS[k][0] 
               
               # Dynamic
               # FISS[0] is q-static, Shifted for next dynamic FISS[2][n] 
               ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1)   
               print "\n   Creating new dynamic crack " +str(ff)           
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_P),#P_FISS[k],   # This has been propagated
                                   FISS_PROPAGEE=CO(ff),
                                   NB_POINT_FOND=nb_pts,
                                   TABLE=SIFF[k],),
                       DA_MAX=da_max,
                       INFO=1,);  

               FISS[k][2+i] = eval(ff)
               print FISS[k][2+i]

           if(eval(F_D) in N_FISS): # Crack not intiated yet
               print "\n   N_FISS is populated with crack: "+str(F_D)  
               if(G==0): # Bypassing issue with no cracks propagating at all and if it has not initiated
                   print "    Propagation_0 ...Crack not initiated using intial cracks in list - L_Int_Crack"
                   if(k==0):
                       F = "FISIN"	
                   if(k==1):					   	   
                       F = "FISIN2"					
                   # Dummy model is not XFEM for intial crack... avoids XFEM crack clash
                   DUMMOD=AFFE_MODELE(MAILLAGE = MA,
                                      AFFE =_F(GROUP_MA = ('VOLUME','FACE_SUP','FACE_INF'),
                                      PHENOMENE    = 'MECANIQUE',
                                      MODELISATION = '3D'),);					
                   # Quasi-static 
                   ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1) 
                   print "\n   Creating new quasi-static crack "  +str(ff)                   
                   PROPA_FISS(MODELE=DUMMOD,
                                  METHODE_PROPA='COHESIVE',
                                  CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                                  ZONE_MAJ='TOUT',
                                  TEST_MAIL='NON',
                                  FISSURE=_F(FISS_ACTUELLE=eval(F),
                                             FISS_PROPAGEE=CO(ff),
                                             NB_POINT_FOND=nb_pts,
                                             TABLE=SIFIN[0],),
                                  DA_MAX=da_max,
                                  INFO=1,);
                   FISS[k][0] = eval(ff)
                        
                   # split for data structure, to avoid a fake enriched model		 
                   # Dynamic
                   ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1) 	
                   print "\n   Creating new dynamic crack " +str(ff)                
                   PROPA_FISS(MODELE=DUMMOD,
                                  METHODE_PROPA='COHESIVE',
                                  CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                                  ZONE_MAJ='TOUT',
                                  TEST_MAIL='NON',
                                  FISSURE=_F(FISS_ACTUELLE=eval(F),
                                             FISS_PROPAGEE=CO(ff),
                                             NB_POINT_FOND=nb_pts,
                                             TABLE=SIFIN[1],),
                                  DA_MAX=da_max,
                                  INFO=1,);
                   FISS[k][2+i] = eval(ff)					   

               else: # It has arrested so can still be a XFEM crack
                   
                   DUMMOD=MODI_MODELE_XFEM(MODELE_IN=MO,
                                        FISSURE=eval(F_P),#crack_arg,
                                        CONTACT='NON',);		 
                                        
                   ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1)
                   print "\n   Creating new quasi-static crack"  +str(ff)      
               # q-static
                   PROPA_FISS(MODELE=DUMMOD,
                           METHODE_PROPA='COHESIVE',
                           CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                           ZONE_MAJ='TOUT',
                           TEST_MAIL='NON',
                           FISSURE=_F(FISS_ACTUELLE=eval(F_D),#FISIN,#,#N_FISS[k],
                                      FISS_PROPAGEE=CO(ff),
                                      NB_POINT_FOND=nb_pts,
                                      TABLE=SIFF[k],),
                           DA_MAX=da_max,
                          INFO=1,);
                
                   FISS[k][0] = eval(ff) # FISS[0][0],FISS[0][1] always q-static
                   print FISS[k][0] 
                   
               # Dynamic

                   print 'k is %d'%k
                   # FISS[0] is q-static, Shifted for next dynamic FISS[2][n]
                   ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1)
                   print "\n   Creating new dynamic crack"  +str(ff)    
                   print f            
                   PROPA_FISS(MODELE=DUMMOD,
                           METHODE_PROPA='COHESIVE',
                           CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                           ZONE_MAJ='TOUT',
                           TEST_MAIL='NON',
                           FISSURE=_F(FISS_ACTUELLE=eval(F_D),#FISIN2,#,#N_FISS[k],
                                       FISS_PROPAGEE=CO(ff),
                                       NB_POINT_FOND=nb_pts,
                                       TABLE=SIFF[k],),
                           DA_MAX=da_max,
                           INFO=1,);  

                   FISS[k][2+i] = eval(ff)
                   print FISS[k][2+i]
                       
           if(eval(F_P) in PN_FISS): # No angle calculation but propagate
               print "\n   PN_FISS is populated with crack: "+str(F_P) 			   
               crack_arg = tuple(PN_FISS)
               DUMMOD=MODI_MODELE_XFEM(MODELE_IN=MO,
                                    FISSURE=eval(F_P),#crack_arg,
                                    CONTACT='NON',);		 
               ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1)  
               print "\n   Creating new quasi-static crack "  +str(ff)    
           # q-static
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_P),#PN_FISS[k],
                                  FISS_PROPAGEE=CO(ff),
                                  NB_POINT_FOND=nb_pts,
                                  TABLE=SIFF[k],),
                       DA_MAX=da_max,
                      INFO=1,);
            
               FISS[k][0] = eval(ff) # FISS[0][0],FISS[0][1] always q-static
               print FISS[k][0] 
               
           # Dynamic
               # FISS[0] is q-static, Shifted for next dynamic FISS[2][n]
               ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1)
               print "\n   Creating new dynamic crack "  +str(ff)    
               print F_P           
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_P),#PN_FISS[k],
                                   FISS_PROPAGEE=CO(ff),
                                   NB_POINT_FOND=nb_pts,
                                   TABLE=SIFF[k],),
                       DA_MAX=da_max,
                       INFO=1,);  

               FISS[k][2+i] = eval(ff)
               print FISS[k][2+i]

           if(eval(F_P) in A_FISS): # Arrested for i
               print "\n   A_FISS is populated with crack: "+str(F_P)			   
               crack_arg = tuple(A_FISS)
               DUMMOD=MODI_MODELE_XFEM(MODELE_IN=MO,
                                    FISSURE=eval(F_D),#crack_arg,
                                    CONTACT='NON',);		 
               ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1)  
               print "\n   Creating new quasi-static crack"  +str(ff)    
           # q-static
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_D),#A_FISS[k],
                                  FISS_PROPAGEE=CO(ff),
                                  NB_POINT_FOND=nb_pts,
                                  TABLE=SIFF[k],),
                       DA_MAX=da_max,
                      INFO=1,);
            
               FISS[k][0] = eval(ff) # FISS[0][0],FISS[0][1] always q-static
               print 'k is %d'%k
               print FISS[k][0] 
               
           # Dynamic

               print 'k is %d'%k
               # FISS[0] is q-static, Shifted for next dynamic FISS[2][n]
               ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1)
               print "\n   Creating new dynamic crack"  +str(ff)    
               print F_P            
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_D),#A_FISS[k],
                                   FISS_PROPAGEE=CO(ff),
                                   NB_POINT_FOND=nb_pts,
                                   TABLE=SIFF[k],),
                       DA_MAX=da_max,
                       INFO=1,);  

               FISS[k][2+i] = eval(ff)
               print FISS[k][2+i]		   
         
           if(eval(F_P) in N_FISS): # In N_FISS as F_P## Arrested for i ignoring A_FISS
               print "\n   N_FISS is populated with crack: "+str(F_P)			   
               crack_arg = tuple(A_FISS)
               DUMMOD=MODI_MODELE_XFEM(MODELE_IN=MO,
                                    FISSURE=eval(F_D),#crack_arg,
                                    CONTACT='NON',);		 
               ff = "C_"+str(k)+"_"+str(0)+"_"+str(i+1)  
               print "\n   Creating new quasi-static crack "  +str(ff)    
           # q-static
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_D),#A_FISS[k],
                                  FISS_PROPAGEE=CO(ff),
                                  NB_POINT_FOND=nb_pts,
                                  TABLE=SIFF[k],),
                       DA_MAX=da_max,
                      INFO=1,);
            
               FISS[k][0] = eval(ff) # FISS[0][0],FISS[0][1] always q-static
               print 'k is %d'%k
               print FISS[k][0] 
               
           # Dynamic

               print 'k is %d'%k
               # FISS[0] is q-static, Shifted for next dynamic FISS[2][n]
               ff = "C_"+str(k)+"_"+str(1)+"_"+str(i+1)
               print "\n   Creating new dynamic crack "  +str(ff)    
               print F_P           
               PROPA_FISS(MODELE=DUMMOD,
                       METHODE_PROPA='COHESIVE',
                       CRIT_ANGL_BIFURCATION='ANGLE_IMPO',
                       ZONE_MAJ='TOUT',
                       TEST_MAIL='NON',
                       FISSURE=_F(FISS_ACTUELLE=eval(F_D),#A_FISS[k],
                                   FISS_PROPAGEE=CO(ff),
                                   NB_POINT_FOND=nb_pts,
                                   TABLE=SIFF[k],),
                       DA_MAX=da_max,
                       INFO=1,);  

               FISS[k][2+i] = eval(ff)
               print FISS[k][2+i]		   

#-----------------------------    DECISION 3 - What do do?   -------------------------#	
           DETRUIRE(CONCEPT=_F(NOM=DUMMOD),INFO=1);	# Model redefined each crack
           print "\n #-----------------------------------------------------------"
           print "   SUMMARY:- Propagation_" + str(i)	   	   
           print "\n #-----------------------------------------------------------"	   
           crack_arg= tuple(P_FISS + N_FISS + PN_FISS) 
           cnames= tuple(P_name + N_name + PN_name) 
           print "   COUNT TEST Cracks for next nbcalc " + str(len(crack_arg))+ " = "+ str(int_nb_cracks)
           print "   List of cracks for next time step"+ str(cnames)	
           print "   Memory locations for cracks: "+str(crack_arg)
           ps=[]
           ps.append("Propagation_" + str(i))
           ps.append("dD_A = " + str(dD_A))			   
           ps.append("N_FISS:" + str(N_name))
           ps.append("NP_FISS:" + str(PN_name))
           ps.append("P_FISS:" + str(P_name))
           ps.append("NEW_CRACK = "+"FISS["+str(ff)+"][DYNAMIC]" )		   		   
           Prop_sum.append(ps) # adding to total summary
           print "#----------------------------------------------------------- \n"	

    #---------------------------------------------------------------------------------#
    # IF last step 	
    if(i==(nbcalc-1)):	
        print "Last time step: \n"
        EVOL[i]=DYNA_NON_LINE(reuse=EVOL[i],
                                 ETAT_INIT  = _F(DEPL = CH1, SIGM=CH2,),
                                 MODELE     = MODX[i],
                                 CHAM_MATER = CHAMM[i],
                                 MASS_DIAG  = 'OUI',
                                 EXCIT      = (_F(CHARGE = RIGID[i]),
                                               _F(CHARGE = TRACI[i],
                                                  FONC_MULT = TRACT_X),
                                               ),
                                COMPORTEMENT = (_F(RELATION = 'ELAS', 
                                                   GROUP_MA = 'VOLUME'),
                                               ),
                                INCREMENT  = _F(LIST_INST = INSTANTX,
                                                INST_INIT = tdyn,
                                                INST_FIN = instfin[i],
                                                PRECISION = 1.E-9),
                                SCHEMA_TEMPS=_F(SCHEMA='DIFF_CENT',
                                                FORMULATION='ACCELERATION',
                                                STOP_CFL = 'NON'),
                                CONVERGENCE= _F(ITER_GLOB_MAXI = 50),
                                NEWTON     = _F(MATRICE = 'TANGENTE',
                                                REAC_ITER=1),
                                ARCHIVAGE = _F(LIST_INST = INS_AR,
                                               PRECISION=1.E-9,
                                               CHAM_EXCLU='VARI_ELGA')
                                );
                                
            # Restrict to result (recover)
        EVOL[i] = EXTR_RESU(reuse=EVOL[i],
                               RESULTAT=EVOL[i],
                               ARCHIVAGE=_F(LIST_INST = INS_AR,
                                            PRECISION=1.E-7,)); 

    DETRUIRE(CONCEPT=_F(NOM=CH1),INFO=1);
    DETRUIRE(CONCEPT=_F(NOM=CH2),INFO=1);
    DETRUIRE(CONCEPT=_F(NOM=MODK),INFO=1);
    DETRUIRE(CONCEPT=_F(NOM=CTX),INFO=1);      
    DETRUIRE(CONCEPT=_F(NOM=CHAMPMA),INFO=1);
    DETRUIRE(CONCEPT=_F(NOM=RIGIDE),INFO=1);
    DETRUIRE(CONCEPT=_F(NOM=TRACTION),INFO=1);     
    try: 
		del P_FISS, N_FISS, PN_FISS, GG, tmp, tab, ps
		del P_name, N_name, PN_name 
    except:
		pass
				    
    # Prints a total summary each nbcalc
    print"\n =========================================================== \n"
    print "   Propagation "+str(i)+" of "+str(nbcalc-1)+" - PHASE 2 ENDED  \n\n   TOTAL PROPAGATION SUMMARY \n"
    for PS in range(len(Prop_sum)):
        if (PS % 2 != 0): # Modolo of number is not zero
            print Prop_sum[PS] 			   			   	   		   						   
    print"\n =========================================================== \n"	   
   

print "\n #===========================================================# \n"
print "   PHASE 3 - Post processing"
print "\n #===========================================================# \n"
# recovering level sets (numbering)
MA_XFEM=POST_MAIL_XFEM(MODELE=MODX[nbcalc-1]);

# Create model
MOD_VISU=AFFE_MODELE(MAILLAGE=MA_XFEM,
                     	AFFE=_F(TOUT='OUI',
                        	     PHENOMENE='MECANIQUE',
                    	         MODELISATION='3D'));
                             
# process and calculate results fields
RESXFEM1=POST_CHAM_XFEM(RESULTAT=EVOL[nbcalc-1],
                	        MODELE_VISU=MOD_VISU);
                        
RESXFEM1=CALC_CHAMP(reuse=RESXFEM1,
            	        RESULTAT=RESXFEM1,
        	            CONTRAINTE='SIGM_NOEU',
      	              CRITERES=('SIEQ_ELGA','SIEQ_ELNO'))

# Print results               
IMPR_RESU(FORMAT='MED',
 	         RESU=_F(RESULTAT=RESXFEM1),);

# Delete these so we can repeat each step of propagation
DETRUIRE(CONCEPT=_F(NOM=MA_XFEM),INFO=1);
DETRUIRE(CONCEPT=_F(NOM=MOD_VISU),INFO=1);
DETRUIRE(CONCEPT=_F(NOM=RESXFEM1),INFO=1);

FIN();
